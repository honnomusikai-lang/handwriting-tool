<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ストローク仕分け機 v1.2</title>
    <style>
        /* 全体のタッチ挙動を制限 */
        body { 
            font-family: sans-serif; 
            display: flex; flex-direction: column; align-items: center; 
            background: #f0f0f0; 
            margin: 0; padding: 10px; 
            height: 100vh; height: 100dvh; /* iOS対応 */
            box-sizing: border-box; 
            touch-action: none; /* ブラウザ標準のパン・ズームを禁止 */
            overflow: hidden; /* スクロール禁止 */
        }
        
        h1 { margin: 0 0 10px 0; font-size: 1rem; color: #555; pointer-events: none; }
        
        #file-area { margin-bottom: 20px; text-align: center; }
        input[type=file] { font-size: 1rem; }
        
        #work-area { 
            display: none; flex-direction: column; align-items: center; width: 100%; height: 100%;
        }

        #status-panel {
            background: white; padding: 10px; border-radius: 8px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 10px;
            text-align: center; width: 100%; max-width: 600px;
            flex: 0 0 auto;
            pointer-events: none; /* 誤操作防止 */
        }
        
        #target-char { font-size: 3rem; font-weight: bold; color: #e00; line-height: 1; margin: 5px 0; }
        #target-context { font-size: 1rem; color: #888; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        #canvas-wrapper {
            flex: 1;
            width: 100%; max-width: 800px;
            position: relative;
            background: #fff;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            margin-bottom: 10px;
            border-radius: 4px;
            overflow: hidden;
        }
        
        canvas { display: block; width: 100%; height: 100%; cursor: pointer; touch-action: none; }

        .controls { display: flex; gap: 10px; width: 100%; max-width: 600px; justify-content: center; flex: 0 0 auto; padding-bottom: 20px; }
        button {
            padding: 15px 0; width: 100%; font-size: 1rem; border: none; border-radius: 8px;
            font-weight: bold; cursor: pointer; color: white;
            touch-action: manipulation;
            pointer-events: auto;
        }
        .btn-back { background: #888; flex: 1; }
        .btn-next { background: #007aff; flex: 2; }
        .btn-save { background: #34c759; display: none; width: 100%; }

    </style>
</head>
<body>

    <h1>ストローク仕分け機 v1.2</h1>
    
    <div id="file-area">
        <p>iPadのデータを選択してください</p>
        <input type="file" id="file-input" accept=".json">
    </div>

    <div id="work-area">
        <div id="status-panel">
            <div id="target-context">読み込み中...</div>
            <div id="target-char">?</div>
            <div style="font-size: 0.8rem; color:#666;">この文字の線をすべてタップ</div>
        </div>

        <div id="canvas-wrapper">
            <canvas id="main-canvas"></canvas>
        </div>

        <div class="controls">
            <button class="btn-back" onclick="prevChar()">戻る</button>
            <button class="btn-next" onclick="confirmAndNext()">確定して次へ</button>
            <button class="btn-save" onclick="saveData()">保存して終了</button>
        </div>
    </div>

    <script>
        // --- ズーム禁止の魔法 (ここが重要) ---
        document.addEventListener('gesturestart', function(e) {
            e.preventDefault(); // ピンチズーム禁止
        });
        document.addEventListener('dblclick', function(e) {
            e.preventDefault(); // ダブルタップ禁止
        }, { passive: false });
        
        // --- 以下ロジック ---
        let rawData = [];
        let labeledData = {}; 
        
        let currentLineIndex = 0;
        let currentCharIndex = 0;
        let strokesInLine = [];
        let strokeAssignments = []; 
        
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const wrapper = document.getElementById('canvas-wrapper');
        
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;

        document.getElementById('file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const json = JSON.parse(e.target.result);
                    rawData = json.data ? json.data : (Array.isArray(json) ? json : []);
                    if (rawData.length === 0) { alert("データが空です"); return; }
                    startLabeling();
                } catch (err) { alert("エラー: " + err); }
            };
            reader.readAsText(file);
        });

        function startLabeling() {
            document.getElementById('file-area').style.display = 'none';
            document.getElementById('work-area').style.display = 'flex';
            currentLineIndex = 0;
            currentCharIndex = 0;
            loadLine(0);
        }

        function loadLine(index) {
            if (index >= rawData.length) { finishAll(); return; }
            const line = rawData[index];
            strokesInLine = line.strokes;
            strokeAssignments = new Array(strokesInLine.length).fill(-1);
            
            setTimeout(() => {
                resizeCanvas();
                updateUI();
            }, 100);
        }

        function resizeCanvas() {
            if (strokesInLine.length === 0) return;

            const wrapRect = wrapper.getBoundingClientRect();
            // Retina対応（ぼやけ防止）
            const dpr = window.devicePixelRatio || 1;
            canvas.width = wrapRect.width * dpr;
            canvas.height = wrapRect.height * dpr;
            canvas.style.width = wrapRect.width + "px";
            canvas.style.height = wrapRect.height + "px";
            
            ctx.scale(dpr, dpr);

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            strokesInLine.forEach(s => s.forEach(p => {
                if(p.x < minX) minX = p.x;
                if(p.x > maxX) maxX = p.x;
                if(p.y < minY) minY = p.y;
                if(p.y > maxY) maxY = p.y;
            }));
            
            const padding = 40;
            const contentW = maxX - minX;
            const contentH = maxY - minY;
            
            // ラッパーの大きさ基準でスケール計算
            const scaleX = (wrapRect.width - padding * 2) / contentW;
            const scaleY = (wrapRect.height - padding * 2) / contentH;
            scale = Math.min(scaleX, scaleY, 2.0); 
            
            const contentCenterX = minX + contentW / 2;
            const contentCenterY = minY + contentH / 2;
            
            // 描画用のオフセット
            offsetX = (wrapRect.width / 2) / scale - contentCenterX;
            offsetY = (wrapRect.height / 2) / scale - contentCenterY;
            
            draw();
        }

        function updateUI() {
            const line = rawData[currentLineIndex];
            const text = line.text;
            
            if (currentCharIndex >= text.length) {
                currentLineIndex++;
                currentCharIndex = 0;
                loadLine(currentLineIndex);
                return;
            }

            const char = text[currentCharIndex];
            if (char === ' ' || char === '　') {
                currentCharIndex++;
                updateUI();
                return;
            }

            document.getElementById('target-char').innerText = char;
            
            const pre = text.substring(0, currentCharIndex);
            const post = text.substring(currentCharIndex + 1);
            document.getElementById('target-context').innerHTML = 
                `<span style="color:#ccc">${pre}</span> <b>${char}</b> <span style="color:#ccc">${post}</span>`;
                
            draw();
        }

        function draw() {
            const wrapRect = wrapper.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            ctx.clearRect(0, 0, wrapRect.width, wrapRect.height);
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            strokesInLine.forEach((stroke, i) => {
                const assigned = strokeAssignments[i];
                
                ctx.beginPath();
                const start = stroke[0];
                ctx.moveTo((start.x + offsetX) * scale, (start.y + offsetY) * scale);
                
                for (let j = 1; j < stroke.length; j++) {
                    const p = stroke[j];
                    ctx.lineTo((p.x + offsetX) * scale, (p.y + offsetY) * scale);
                }

                if (assigned === currentCharIndex) {
                    ctx.strokeStyle = '#ff0000'; 
                    ctx.lineWidth = 4;
                    ctx.globalAlpha = 1.0;
                } else if (assigned !== -1 && assigned < currentCharIndex) {
                    ctx.strokeStyle = '#00cc00'; 
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.2;
                } else {
                    ctx.strokeStyle = '#000000'; 
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 1.0;
                }
                
                ctx.stroke();
            });
            ctx.globalAlpha = 1.0;
        }

        // --- 操作 ---
        canvas.addEventListener('pointerdown', function(e) {
            e.preventDefault(); 
            // 座標計算の修正（スケールとオフセットを考慮）
            const rect = canvas.getBoundingClientRect();
            // touchイベントの座標補正
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            let minDist = Infinity;
            let targetIdx = -1;
            
            strokesInLine.forEach((stroke, i) => {
                if (strokeAssignments[i] !== -1 && strokeAssignments[i] < currentCharIndex) return;

                for (let p of stroke) {
                    // 描画座標を再現
                    const sx = (p.x + offsetX) * scale;
                    const sy = (p.y + offsetY) * scale;
                    
                    const dist = Math.hypot(sx - clickX, sy - clickY);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        targetIdx = i;
                    }
                }
            });

            // 判定距離（画面上のピクセルで40px以内）
            if (minDist < 40 && targetIdx !== -1) {
                if (strokeAssignments[targetIdx] === currentCharIndex) {
                    strokeAssignments[targetIdx] = -1; 
                } else {
                    strokeAssignments[targetIdx] = currentCharIndex;
                }
                draw();
            }
        });

        function confirmAndNext() {
            const char = rawData[currentLineIndex].text[currentCharIndex];
            const selectedStrokes = [];
            strokesInLine.forEach((s, i) => {
                if (strokeAssignments[i] === currentCharIndex) {
                    // 保存時に座標を正規化（文字の中心を0,0にする）しておくと便利
                    // ここでは後でPython処理するためにそのまま保存
                    selectedStrokes.push(s); 
                }
            });

            if (selectedStrokes.length > 0) {
                if (!labeledData[char]) labeledData[char] = [];
                labeledData[char].push(selectedStrokes);
            }
            currentCharIndex++;
            updateUI();
        }

        function prevChar() {
            if (currentCharIndex > 0) {
                currentCharIndex--;
                // 戻ったときに、その文字に割り当てていた選択を解除するならここ
                // strokeAssignments.forEach((v,i) => { if(v === currentCharIndex) strokeAssignments[i] = -1; });
                updateUI();
            } else {
                alert("これ以上戻れません");
            }
        }

        function finishAll() {
            document.getElementById('status-panel').innerHTML = "<h2 style='color:#34c759'>完了！</h2><p>お疲れ様でした。</p>";
            document.querySelector('.btn-back').style.display = 'none';
            document.querySelector('.btn-next').style.display = 'none';
            document.querySelector('.btn-save').style.display = 'block';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function saveData() {
            const jsonString = JSON.stringify(labeledData);
            const blob = new Blob([jsonString], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `labeled_handwriting.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        
        window.addEventListener('resize', () => {
            setTimeout(resizeCanvas, 200);
        });

    </script>
</body>
</html>
