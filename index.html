<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ストローク仕分け機</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f0f0; margin: 0; padding: 20px; height: 100vh; box-sizing: border-box; }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; }
        
        #file-area { margin-bottom: 10px; }
        
        #work-area { 
            display: none; flex-direction: column; align-items: center; width: 100%; flex: 1;
        }

        #status-panel {
            background: white; padding: 10px 20px; border-radius: 8px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 10px;
            text-align: center; width: 100%; max-width: 600px;
        }
        
        #target-char { font-size: 3rem; font-weight: bold; color: #e00; line-height: 1.2; }
        #target-context { font-size: 1rem; color: #888; }
        
        #canvas-container {
            position: relative;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            background: white;
            margin-bottom: 10px;
            overflow: hidden;
            touch-action: none; /* 重要 */
        }
        
        canvas { display: block; cursor: pointer; }

        .controls { display: flex; gap: 20px; width: 100%; max-width: 600px; justify-content: center; }
        button {
            padding: 15px 30px; font-size: 1rem; border: none; border-radius: 8px;
            font-weight: bold; cursor: pointer; color: white;
        }
        .btn-back { background: #888; }
        .btn-next { background: #007aff; flex: 1; }
        .btn-save { background: #34c759; display: none; }

        .highlight { background: #ffcccc; }
    </style>
</head>
<body>

    <h1>ストローク仕分け機</h1>
    
    <div id="file-area">
        <input type="file" id="file-input" accept=".json">
        <p style="font-size:0.8rem">※iPadで集めたJSONファイルを選択してください</p>
    </div>

    <div id="work-area">
        <div id="status-panel">
            <div id="target-context">読み込み中...</div>
            <div id="target-char">?</div>
            <div style="font-size: 0.8rem; margin-top:5px;">この文字の線をすべてタップしてください</div>
        </div>

        <div id="canvas-container">
            <canvas id="main-canvas"></canvas>
        </div>

        <div class="controls">
            <button class="btn-back" onclick="prevChar()">＜ 戻る</button>
            <button class="btn-next" onclick="confirmAndNext()">確定して次へ ＞</button>
            <button class="btn-save" onclick="saveData()">保存する</button>
        </div>
    </div>

    <script>
        let rawData = [];
        let labeledData = {}; // { "あ": [ [stroke...], [stroke...] ] }
        
        // 作業状態
        let currentLineIndex = 0;
        let currentCharIndex = 0;
        let strokesInLine = []; // その行の全ストローク
        let strokeAssignments = []; // ストロークごとの所属文字インデックス (-1は未割り当て)
        
        // Canvas設定
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        let scale = 1;
        let offsetX = 0;

        // --- ファイル読み込み ---
        document.getElementById('file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const json = JSON.parse(e.target.result);
                    // v3.9の形式に対応
                    rawData = json.data ? json.data : (Array.isArray(json) ? json : []);
                    
                    if (rawData.length === 0) { alert("データが空です"); return; }
                    
                    startLabeling();
                } catch (err) {
                    alert("読み込みエラー: " + err);
                }
            };
            reader.readAsText(file);
        });

        function startLabeling() {
            document.getElementById('file-area').style.display = 'none';
            document.getElementById('work-area').style.display = 'flex';
            
            currentLineIndex = 0;
            currentCharIndex = 0;
            loadLine(0);
        }

        function loadLine(index) {
            if (index >= rawData.length) {
                finishAll();
                return;
            }
            
            const line = rawData[index];
            // スペースは飛ばす処理を入れてもいいが、今回はそのまま表示してスキップさせる
            strokesInLine = line.strokes;
            
            // ストロークの所属をリセット (-1:未割り当て)
            strokeAssignments = new Array(strokesInLine.length).fill(-1);
            
            // Canvasサイズ調整
            resizeCanvas();
            updateUI();
        }

        function resizeCanvas() {
            // ストロークの範囲を計算
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            strokesInLine.forEach(s => s.forEach(p => {
                if(p.x < minX) minX = p.x;
                if(p.x > maxX) maxX = p.x;
                if(p.y < minY) minY = p.y;
                if(p.y > maxY) maxY = p.y;
            }));
            
            // 余白
            const padding = 50;
            const contentW = maxX - minX + padding * 2;
            const contentH = maxY - minY + padding * 2;
            
            // 画面幅に合わせる
            const screenW = Math.min(window.innerWidth - 40, 800);
            scale = screenW / contentW;
            
            canvas.width = screenW;
            canvas.height = contentH * scale;
            
            // 描画オフセット
            offsetX = -minX + padding;
            
            draw();
        }

        function updateUI() {
            const line = rawData[currentLineIndex];
            const text = line.text;
            
            if (currentCharIndex >= text.length) {
                // 行終了 -> 次の行へ
                currentLineIndex++;
                currentCharIndex = 0;
                loadLine(currentLineIndex);
                return;
            }

            const char = text[currentCharIndex];
            
            // スペースの場合は自動スキップ
            if (char === ' ' || char === '　') {
                currentCharIndex++;
                updateUI();
                return;
            }

            document.getElementById('target-char').innerText = char;
            
            // 文脈表示 (前後を表示)
            const pre = text.substring(0, currentCharIndex);
            const post = text.substring(currentCharIndex + 1);
            document.getElementById('target-context').innerHTML = 
                `<span style="color:#ccc">${pre}</span> <b>${char}</b> <span style="color:#ccc">${post}</span>`;
                
            draw();
        }

        // --- 描画 ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            strokesInLine.forEach((stroke, i) => {
                const assigned = strokeAssignments[i];
                
                ctx.beginPath();
                // 座標変換
                const start = stroke[0];
                ctx.moveTo((start.x + offsetX) * scale, start.y * scale);
                
                for (let j = 1; j < stroke.length; j++) {
                    const p = stroke[j];
                    ctx.lineTo((p.x + offsetX) * scale, p.y * scale);
                }

                // 色分け
                if (assigned === currentCharIndex) {
                    // 現在選択中のストローク (赤・太い)
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 4 * scale;
                    ctx.globalAlpha = 1.0;
                } else if (assigned !== -1 && assigned < currentCharIndex) {
                    // 確定済みのストローク (緑・薄い)
                    ctx.strokeStyle = '#00aa00';
                    ctx.lineWidth = 2 * scale;
                    ctx.globalAlpha = 0.3;
                } else {
                    // 未割り当て (黒)
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2 * scale;
                    ctx.globalAlpha = 1.0;
                }
                
                ctx.stroke();
            });
            ctx.globalAlpha = 1.0;
        }

        // --- 操作 ---
        // タッチ判定
        canvas.addEventListener('pointerdown', function(e) {
            const rect = canvas.getBoundingClientRect();
            const clickX = (e.clientX - rect.left);
            const clickY = (e.clientY - rect.top);
            
            // クリック位置に最も近いストロークを探す
            let minDist = Infinity;
            let targetIdx = -1;
            
            strokesInLine.forEach((stroke, i) => {
                // すでに他の文字に確定しているものは除外（修正したい場合は戻るボタンで）
                if (strokeAssignments[i] !== -1 && strokeAssignments[i] !== currentCharIndex) return;

                // ストローク内の各点との距離を測る
                for (let p of stroke) {
                    const sx = (p.x + offsetX) * scale;
                    const sy = p.y * scale;
                    const dist = Math.hypot(sx - clickX, sy - clickY);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        targetIdx = i;
                    }
                }
            });

            // 判定範囲 (指だと太いので広めに)
            if (minDist < 40 && targetIdx !== -1) {
                // トグル処理
                if (strokeAssignments[targetIdx] === currentCharIndex) {
                    strokeAssignments[targetIdx] = -1; // 解除
                } else {
                    strokeAssignments[targetIdx] = currentCharIndex; // 選択
                }
                draw();
            }
        });

        function confirmAndNext() {
            // 現在の文字データを保存
            const char = rawData[currentLineIndex].text[currentCharIndex];
            
            // 現在選択されているストロークを抽出
            const selectedStrokes = [];
            strokesInLine.forEach((s, i) => {
                if (strokeAssignments[i] === currentCharIndex) {
                    // 座標を正規化して保存（重要）
                    // ここではとりあえず生のまま保存し、後でPython側で正規化する方が安全
                    selectedStrokes.push(s); 
                }
            });

            if (selectedStrokes.length > 0) {
                if (!labeledData[char]) labeledData[char] = [];
                labeledData[char].push(selectedStrokes);
            }

            currentCharIndex++;
            updateUI();
        }

        function prevChar() {
            if (currentCharIndex > 0) {
                currentCharIndex--;
                // 戻った文字の割り当てを解除（再選択させるため）
                // ※UX的には保持したほうがいいが、修正のためなので解除する
                /*
                for(let i=0; i<strokeAssignments.length; i++) {
                    if (strokeAssignments[i] === currentCharIndex) strokeAssignments[i] = -1;
                }
                */
                // いや、保持したまま戻り、編集できるようにする
                updateUI();
            } else if (currentLineIndex > 0) {
                alert("前の行には戻れません（仕様）");
            }
        }

        function finishAll() {
            document.getElementById('status-panel').innerHTML = "<h2>完了！</h2><p>すべての仕分けが終わりました。</p>";
            document.querySelector('.btn-back').style.display = 'none';
            document.querySelector('.btn-next').style.display = 'none';
            document.querySelector('.btn-save').style.display = 'block';
            draw(); // 最後描画
        }

        function saveData() {
            const jsonString = JSON.stringify(labeledData);
            const blob = new Blob([jsonString], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `labeled_handwriting.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

    </script>
</body>
</html>
