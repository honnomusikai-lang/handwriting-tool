<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ストローク仕分け機 v1.1</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f0f0; margin: 0; padding: 10px; height: 100vh; box-sizing: border-box; touch-action: none; }
        
        h1 { margin: 0 0 10px 0; font-size: 1rem; color: #555; }
        
        #file-area { margin-bottom: 20px; text-align: center; }
        input[type=file] { font-size: 1rem; }
        
        #work-area { 
            display: none; flex-direction: column; align-items: center; width: 100%; height: 100%;
        }

        #status-panel {
            background: white; padding: 10px; border-radius: 8px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 10px;
            text-align: center; width: 100%; max-width: 600px;
            flex: 0 0 auto; /* 高さを固定 */
        }
        
        #target-char { font-size: 3rem; font-weight: bold; color: #e00; line-height: 1; margin: 5px 0; }
        #target-context { font-size: 1rem; color: #888; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        #canvas-wrapper {
            flex: 1; /* 残りの高さを埋める */
            width: 100%; max-width: 800px;
            position: relative;
            background: #fff;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            margin-bottom: 10px;
            border-radius: 4px;
            overflow: hidden;
        }
        
        canvas { display: block; width: 100%; height: 100%; cursor: pointer; }

        .controls { display: flex; gap: 10px; width: 100%; max-width: 600px; justify-content: center; flex: 0 0 auto; padding-bottom: 10px; }
        button {
            padding: 15px 0; width: 100%; font-size: 1rem; border: none; border-radius: 8px;
            font-weight: bold; cursor: pointer; color: white;
            touch-action: manipulation;
        }
        .btn-back { background: #888; flex: 1; }
        .btn-next { background: #007aff; flex: 2; }
        .btn-save { background: #34c759; display: none; width: 100%; }

    </style>
</head>
<body>

    <h1>ストローク仕分け機 v1.1</h1>
    
    <div id="file-area">
        <p>iPadのデータを選択してください</p>
        <input type="file" id="file-input" accept=".json">
    </div>

    <div id="work-area">
        <div id="status-panel">
            <div id="target-context">読み込み中...</div>
            <div id="target-char">?</div>
            <div style="font-size: 0.8rem; color:#666;">この文字の線をすべてタップ</div>
        </div>

        <div id="canvas-wrapper">
            <canvas id="main-canvas"></canvas>
        </div>

        <div class="controls">
            <button class="btn-back" onclick="prevChar()">戻る</button>
            <button class="btn-next" onclick="confirmAndNext()">確定して次へ</button>
            <button class="btn-save" onclick="saveData()">保存して終了</button>
        </div>
    </div>

    <script>
        let rawData = [];
        let labeledData = {}; 
        
        let currentLineIndex = 0;
        let currentCharIndex = 0;
        let strokesInLine = [];
        let strokeAssignments = []; 
        
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const wrapper = document.getElementById('canvas-wrapper');
        
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0; // 追加: Y軸補正用

        // --- ファイル読み込み ---
        document.getElementById('file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const json = JSON.parse(e.target.result);
                    rawData = json.data ? json.data : (Array.isArray(json) ? json : []);
                    if (rawData.length === 0) { alert("データが空です"); return; }
                    startLabeling();
                } catch (err) { alert("エラー: " + err); }
            };
            reader.readAsText(file);
        });

        function startLabeling() {
            document.getElementById('file-area').style.display = 'none';
            document.getElementById('work-area').style.display = 'flex';
            currentLineIndex = 0;
            currentCharIndex = 0;
            loadLine(0);
        }

        function loadLine(index) {
            if (index >= rawData.length) { finishAll(); return; }
            const line = rawData[index];
            strokesInLine = line.strokes;
            strokeAssignments = new Array(strokesInLine.length).fill(-1);
            
            // レイアウト再計算（ここが重要）
            // 少し遅延させて、DOMのサイズが確定してから計算する
            setTimeout(() => {
                resizeCanvas();
                updateUI();
            }, 100);
        }

        // --- 修正されたキャンバスリサイズ ---
        function resizeCanvas() {
            if (strokesInLine.length === 0) return;

            // ラッパーのサイズを取得
            const wrapRect = wrapper.getBoundingClientRect();
            canvas.width = wrapRect.width;
            canvas.height = wrapRect.height;

            // ストローク全体の範囲を計算
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            strokesInLine.forEach(s => s.forEach(p => {
                if(p.x < minX) minX = p.x;
                if(p.x > maxX) maxX = p.x;
                if(p.y < minY) minY = p.y;
                if(p.y > maxY) maxY = p.y;
            }));
            
            // 余白（上下左右）
            const padding = 40;
            const contentW = maxX - minX;
            const contentH = maxY - minY;
            
            // スケール計算（幅と高さ、どちらに合わせて縮小するか）
            const scaleX = (canvas.width - padding * 2) / contentW;
            const scaleY = (canvas.height - padding * 2) / contentH;
            scale = Math.min(scaleX, scaleY, 1.5); // 拡大しすぎ防止
            
            // オフセット計算（中央寄せ）
            // コンテンツの中心を、キャンバスの中心に合わせる
            const contentCenterX = minX + contentW / 2;
            const contentCenterY = minY + contentH / 2;
            
            offsetX = (canvas.width / 2) / scale - contentCenterX;
            offsetY = (canvas.height / 2) / scale - contentCenterY;
            
            draw();
        }

        function updateUI() {
            const line = rawData[currentLineIndex];
            const text = line.text;
            
            if (currentCharIndex >= text.length) {
                currentLineIndex++;
                currentCharIndex = 0;
                loadLine(currentLineIndex);
                return;
            }

            const char = text[currentCharIndex];
            if (char === ' ' || char === '　') {
                currentCharIndex++;
                updateUI();
                return;
            }

            document.getElementById('target-char').innerText = char;
            
            const pre = text.substring(0, currentCharIndex);
            const post = text.substring(currentCharIndex + 1);
            document.getElementById('target-context').innerHTML = 
                `<span style="color:#ccc">${pre}</span> <b>${char}</b> <span style="color:#ccc">${post}</span>`;
                
            draw();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            strokesInLine.forEach((stroke, i) => {
                const assigned = strokeAssignments[i];
                
                ctx.beginPath();
                
                // ★修正: XもYもオフセットしてスケーリング
                const start = stroke[0];
                ctx.moveTo((start.x + offsetX) * scale, (start.y + offsetY) * scale);
                
                for (let j = 1; j < stroke.length; j++) {
                    const p = stroke[j];
                    ctx.lineTo((p.x + offsetX) * scale, (p.y + offsetY) * scale);
                }

                // 色分け
                if (assigned === currentCharIndex) {
                    ctx.strokeStyle = '#ff0000'; // 選択中（赤）
                    ctx.lineWidth = 5 * scale;   // 太く
                    ctx.globalAlpha = 1.0;
                } else if (assigned !== -1 && assigned < currentCharIndex) {
                    ctx.strokeStyle = '#00cc00'; // 確定済み（緑）
                    ctx.lineWidth = 2 * scale;
                    ctx.globalAlpha = 0.2;       // 薄くして邪魔にならないように
                } else {
                    ctx.strokeStyle = '#000000'; // 未選択（黒）
                    ctx.lineWidth = 2 * scale;
                    ctx.globalAlpha = 1.0;
                }
                
                ctx.stroke();
            });
            ctx.globalAlpha = 1.0;
        }

        // --- 操作 ---
        canvas.addEventListener('pointerdown', function(e) {
            e.preventDefault(); // スクロール防止
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            let minDist = Infinity;
            let targetIdx = -1;
            
            strokesInLine.forEach((stroke, i) => {
                // 確定済み（過去の文字）は触れないようにする
                if (strokeAssignments[i] !== -1 && strokeAssignments[i] < currentCharIndex) return;

                // ストロークとの距離判定
                for (let p of stroke) {
                    // 描画されている座標と比較
                    const sx = (p.x + offsetX) * scale;
                    const sy = (p.y + offsetY) * scale;
                    const dist = Math.hypot(sx - clickX, sy - clickY);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        targetIdx = i;
                    }
                }
            });

            // 判定範囲（指でも押しやすいように40px）
            if (minDist < 40 && targetIdx !== -1) {
                // 切り替え
                if (strokeAssignments[targetIdx] === currentCharIndex) {
                    strokeAssignments[targetIdx] = -1; 
                } else {
                    strokeAssignments[targetIdx] = currentCharIndex;
                }
                draw();
            }
        });

        function confirmAndNext() {
            const char = rawData[currentLineIndex].text[currentCharIndex];
            const selectedStrokes = [];
            strokesInLine.forEach((s, i) => {
                if (strokeAssignments[i] === currentCharIndex) {
                    selectedStrokes.push(s); 
                }
            });

            if (selectedStrokes.length > 0) {
                if (!labeledData[char]) labeledData[char] = [];
                labeledData[char].push(selectedStrokes);
            }
            currentCharIndex++;
            updateUI();
        }

        function prevChar() {
            if (currentCharIndex > 0) {
                currentCharIndex--;
                // 戻ったとき、その文字に割り当てていたストロークの選択状態は維持されるので
                // そのまま修正が可能
                updateUI();
            } else {
                alert("これ以上戻れません");
            }
        }

        function finishAll() {
            document.getElementById('status-panel').innerHTML = "<h2 style='color:#34c759'>完了！</h2><p>お疲れ様でした。</p>";
            document.querySelector('.btn-back').style.display = 'none';
            document.querySelector('.btn-next').style.display = 'none';
            document.querySelector('.btn-save').style.display = 'block';
            
            // 完了後はすべて緑色で表示
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#00aa00';
            // ... (簡易表示)
        }

        function saveData() {
            const jsonString = JSON.stringify(labeledData);
            const blob = new Blob([jsonString], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `labeled_handwriting.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        
        // 画面回転時などの対応
        window.addEventListener('resize', () => {
            resizeCanvas();
        });

    </script>
</body>
</html>
